generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// ===================================
// ENUMS
// ===================================

enum UserRole {
    USER
    MODERATOR
    ADMIN
}

enum EventStatus {
    DRAFT
    PENDING // En espera de revisión (Nuevo)
    APPROVED // Publicado (Nuevo)
    DENIED // Rechazado por admin (Nuevo)
}

enum VotingType {
    SINGLE
    MULTIPLE
    LIMITED_MULTIPLE
}

enum ReportReason {
    SPAM
    INAPPROPRIATE_CONTENT
    HARASSMENT
    SCAM
    OTHER
}

// ===================================
// MODELOS DE USUARIO Y CUENTA
// ===================================

model User {
    id                   String            @id @default(uuid())
    name                 String
    username             String            @unique
    email                String            @unique
    emailVerified        DateTime?
    passwordHash         String?
    image                String?
    role                 UserRole          @default(USER) // Nuevo campo de seguridad
    ipBan                Boolean           @default(false) // Nuevo campo de seguridad para bloqueo
    stripeCustomerId     String?           @unique
    stripeSubscriptionId String?           @unique
    stripePriceId        String?
    subscriptionStatus   String?           @default("free")
    subscriptionEndDate  DateTime?
    cancelAtPeriodEnd    Boolean           @default(false)
    createdAt            DateTime          @default(now())
    updatedAt            DateTime          @updatedAt

    // Relaciones
    accounts             Account[]
    events               Event[]
    sessions             Session[]
    votes                Vote[]            @relation(name: "UserVotes")
    notifications        Notification[]
    supportChats         SupportChat[]     @relation(name: "UserSupportChats")
    chatMessages         ChatMessage[]     @relation(name: "UserChatMessages")
    moderationLogs       ModerationLog[]   @relation(name: "AdminActions")
    reports              Report[]          @relation(name: "UserReports")
}

model Account {
    id                String  @id @default(uuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@index([userId])
}

model Session {
    id           String   @id @default(uuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
}

model VerificationToken {
    id         String   @id @default(uuid())
    email      String
    token      String   @unique
    expires    DateTime

    @@unique([email, token])
}

model PasswordResetToken {
    id      String   @id @default(uuid())
    email   String
    token   String   @unique
    expires DateTime

    @@unique([email, token])
}

// ===================================
// MODELOS DE EVENTOS Y VOTACIONES
// ===================================

model Event {
    id             String          @id @default(uuid())
    userId         String          // Creador del evento
    title          String          @db.VarChar(100)
    description    String          @db.Text
    slug           String          @unique // URL amigable (ej: mejor-pelicula-2024)
    accessKey      String          @unique @default(uuid()) // Clave privada para administrar (aparte de userId)
    isPublic       Boolean         @default(false) // Si es visible en la página principal
    tags           String[]        // Etiquetas para búsqueda (ej: ["cine", "oscar", "fiesta"])
    galaDate       DateTime        // Fecha de la celebración o fin del evento
    isAnonymousVoting Boolean       @default(true)
    createdAt      DateTime        @default(now())
    updatedAt      DateTime        @updatedAt

    status            EventStatus     @default(DRAFT) // <--- CAMBIO: Por defecto nace como borrador
    reviewReason      String?   

    // Relaciones
    user           User            @relation(fields: [userId], references: [id])
    participants   Participant[]
    polls          Poll[]
    reports        Report[]
    moderationLogs ModerationLog[]

    @@index([userId])
    @@index([slug])
    @@index([status])
}

model Participant {
    id          String   @id @default(uuid())
    name        String   @db.VarChar(100)
    imageUrl    String?  @db.Text
    eventId     String
    createdAt   DateTime @default(now())

    // Relaciones
    nominations Option[]
    event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

    @@index([eventId])
}

model Poll {
    id            String     @id @default(uuid())
    eventId       String
    title         String     @db.VarChar(100)
    description   String?    @db.Text
    votingType    VotingType @default(SINGLE)
    maxOptions    Int        @default(1) // Solo aplica a LIMITED_MULTIPLE
    isPublished   Boolean    @default(false)
    order         Int        @default(0)
    createdAt     DateTime   @default(now())
    updatedAt     DateTime   @updatedAt

    // Relaciones
    event         Event      @relation(fields: [eventId], references: [id], onDelete: Cascade)
    options       Option[]
    votes         Vote[]

    @@index([eventId])
}

model Option {
    id            String       @id @default(uuid())
    pollId        String
    subtitle      String?      @db.VarChar(100) // Título del premio/categoría si la opción es un participante
    participantId String       // El participante nominado
    order         Int          @default(0)

    // Relaciones
    participant   Participant  @relation(fields: [participantId], references: [id], onDelete: Cascade)
    poll          Poll         @relation(fields: [pollId], references: [id], onDelete: Cascade)
    votes         VoteOption[]

    @@unique([pollId, participantId])
}

model Vote {
    id          String       @id @default(uuid())
    pollId      String
    createdAt   DateTime     @default(now())
    voterHash   String       // Hash de la cookie o IP del votante (si no está logeado)
    userId      String?      // ID del usuario logeado (si está logeado)
    user        User?        @relation(name: "UserVotes", fields: [userId], references: [id])
    poll        Poll         @relation(fields: [pollId], references: [id], onDelete: Cascade)
    voteOptions VoteOption[]

    @@unique([pollId, voterHash])
    @@index([userId])
}

model VoteOption {
    id       String @id @default(uuid())
    voteId   String
    optionId String

    // Relaciones
    option   Option @relation(fields: [optionId], references: [id], onDelete: Cascade)
    vote     Vote   @relation(fields: [voteId], references: [id], onDelete: Cascade)

    @@unique([voteId, optionId])
}

// ===================================
// MODELOS DE MODERACIÓN Y SOPORTE
// ===================================

// NUEVO: Modelo para registrar reportes de usuarios sobre eventos
model Report {
    id          String       @id @default(uuid())
    reporterId  String       // Usuario que reporta
    eventId     String       // Evento reportado
    reason      ReportReason // Razón del reporte (enum)
    details     String       @db.Text
    isReviewed  Boolean      @default(false)
    createdAt   DateTime     @default(now())
    reviewedAt  DateTime?

    // Relaciones
    reporter    User         @relation(name: "UserReports", fields: [reporterId], references: [id])
    event       Event        @relation(fields: [eventId], references: [id])

    @@index([eventId])
    @@index([reporterId])
    @@index([isReviewed])
}

// NUEVO: Historial de acciones tomadas por el admin/moderador
model ModerationLog {
    id            String   @id @default(uuid())
    adminId       String   // Administrador que realiza la acción
    actionType    String   // Tipo de acción (ej: 'APPROVE_EVENT', 'DENY_EVENT', 'BAN_USER', 'RESET_VOTES')
    targetType    String   // Tipo de entidad afectada (ej: 'EVENT', 'USER')
    targetId      String   // ID de la entidad afectada
    details       String?  @db.Text // Detalles o razón de la acción
    createdAt     DateTime @default(now())

    // Relaciones
    admin         User     @relation(name: "AdminActions", fields: [adminId], references: [id])
    // Relación opcional con el Evento, útil para búsquedas rápidas en la tabla de Eventos
    eventId       String?
    event         Event?   @relation(fields: [eventId], references: [id])     

    @@index([adminId])
    @@index([targetId])
    @@index([eventId])
}


model Notification {
    id          String   @id @default(uuid())
    message     String   // El contenido de la notificación
    link        String?  // Enlace directo a la acción (ej: /admin/review/event-id)
    isRead      Boolean  @default(false)
    createdAt   DateTime @default(now())
    adminUserId String   // A qué administrador va dirigida
    userId      String?

    admin User @relation(fields: [adminUserId], references: [id])

    @@index([adminUserId])
}

model SupportChat {
    id            String        @id @default(uuid())
    userId        String        // Usuario que inicia la conversación
    adminId       String?       // Administrador asignado (puede ser null)
    isClosed      Boolean       @default(false)
    createdAt     DateTime      @default(now())
    lastMessageAt DateTime      @updatedAt

    user      User            @relation(name: "UserSupportChats", fields: [userId], references: [id])
    messages  ChatMessage[]

    @@index([userId])
}

model ChatMessage {
    id        String   @id @default(uuid())
    chatId    String
    senderId  String   // userId o adminId (asumimos que si no es userId, es adminId, pero el senderId tiene que ser un ID de la tabla User)
    content   String
    createdAt DateTime @default(now())

    chat      SupportChat @relation(fields: [chatId], references: [id], onDelete: Cascade)
    sender    User        @relation(name: "UserChatMessages", fields: [senderId], references: [id]) // Relación con el User

    @@index([chatId])
}